#pragma GCC optimize(3,"Ofast","inline")
#include "exceptions.hpp"
#include <cstddef>
#include <cstring>
#define R return
#define C const
#define I iterator
#define _ const_iterator
#define O operator
#define B E->nxt
#define L E->pre
#define V this
#define W int
#define cp(a,b) memcpy(a,b,sizeof(T))
namespace sjtu { 
template<class T,W bSiz=999,W wRat=5>
class deque {private:static C W maxW=bSiz / wRat;struct X;class Allocator;public :class I;class _;private:Allocator M;X *E;W sz;
struct X {X *pre,*nxt;T* v;W sz,l,r;char mem[sizeof(T)* bSiz];void reset(){pre=nxt=NULL;l=sz=r=0;v=(T*)mem;}X (){reset();}W lsiz(){R l;}W rsiz(){R bSiz-r;}void dell(){(v+l++)->~T();sz--;}void delr(){(v+--r)->~T();sz--;}void addl(C T& x){if(!sz)l=r=bSiz;if(!lsiz()){W b=(bSiz-sz+1)/2;for(W i=r-1;i >= l;i--)cp(v+i+b,v+i);l+=b,r+=b;}--l,sz++;new(v+l)T(x);}void addr(C T& x){if(!sz)l=r=0;if(!rsiz()){W b=(bSiz-sz+1)/ 2;for(W i=l;i < r;i++)cp(v+i-b,v+i);l-=b,r-=b;}new(v+r)T(x);r++,sz++;}void insert(W p,C T& x){if((p <= sz-p && lsiz())|| !rsiz()){--l;for(W i=0;i < p;i++)cp(v+l+i,v+l+i+1);} else {r++;for(W i=sz-1;i >= p;i--)cp(v+l+i+1,v+l+i);}new(v+l+p)T(x);sz++;}void erase(W p){(v+l+p)->~T();if(p <= sz-p){l++;for(W i=p-1;i >= 0;i--)cp(v+l+i,v+l+i-1);} else {r--;for(W i=p;i < sz-1;i++)cp(v+l+i,v+l+i+1);}sz--;}};class Allocator {public:X* New(bool isE=0){X* r=new X;if(isE)r->sz=r->r=bSiz,r->v=0;R r;}X* New(X *pre,X *nxt){X* r=new X;r->pre=pre,r->nxt=nxt,pre->nxt=r,nxt->pre=r;R r;}void Del(X *x){x->nxt->pre=x->pre,x->pre->nxt=x->nxt;delete x;}};public:class I {public:C deque* id;W rk;X* b;W p;I (){}I (C deque* i,W r): id(i),rk(r){W c=0;b=id->E,p=0;for(X *x=i->B;x != i->E;c+=x->sz,x=x->nxt)if(c+x->sz > rk){b=x,p=rk-c;R;}}I (C deque *i,W r,X *u,W v): id(i),rk(r),b(u),p(v){}I O+(C W &n)C {R I(id,rk+n);}I O-(C W &n)C {R I(id,rk-n);}W O-(C I &o)C {if(id != o.id)throw invalid_iterator();R rk-o.rk;}I O+=(C W &n){R (*V=*V+n);}I O-=(C W &n){R (*V=*V-n);}I& O++(){if(p+1 < b->sz)R *V=I(id,rk+1,b,p+1);else R *V=I(id,rk+1,b->nxt,0);}I O++(W){I r=*V;R ++*V,r;}I& O--(){if(p)R *V=I(id,rk-1,b,p-1);else R *V=I(id,rk-1,b->pre,b->pre->sz-1);}I O--(W){I r=*V;R --*V,r;}T& O*()C {if(!b->v)throw index_out_of_bound();R b->v[b->l+p];}T* O->()C {if(!b->v)throw index_out_of_bound();R b->v+b->l+p;}bool O==(C I &o)C {R id==o.id && rk==o.rk;}bool O!=(C I &o)C {R !(id==o.id && rk==o.rk);}};class _ {I it;public:_(){}_(C _ &o): it(o.it){}_(C I &o): it(o){}C T& O*()C {R *it;}C T* O->()C {R &*it;}W O-(C _ &o)C {R it-o.it;}_ O+(C W &n)C {R _(it+n);}_ O-(C W &n)C {R _(it-n);}_ O+=(C W &n){R (*V=*V+n);}_ O-=(C W &n){R (*V=*V-n);}_ O++ (){++it;R *V;}_ O++ (W){R _(it++);}_ O-- (){--it;R *V;}_ O-- (W){R _(it--);}bool O==(C _ &o)C {R it==o.it;}bool O!=(C _ &o)C {R it != o.it;}};void clear(){for(X *x=B;x != E;x=x->nxt,M.Del(x->pre))for(W i=0;i < x->sz;i++)(x->v+x->l+i)->~T();B=L=E,sz=0;}deque &O=(C deque &o){if(V==&o)R *V;clear();for(X* x=o.B;x != o.E;x=x->nxt)for(W i=0;i < x->sz;i++)push_back(x->v[x->l+i]);R *V;}deque(){E=M.New(1),B=L=E,sz=0;}deque(C deque &o){E=M.New(1),B=L=E,sz=0,*V=o;}~deque(){clear();delete E;}private:void S(X *x){while(x->nxt->sz)x->addr(x->nxt->v[x->nxt->l]),x->nxt->dell();M.Del(x->nxt);}void H(X *x){M.New(x,x->nxt);for(W i=0;i < x->sz;i++)x->nxt->addl(x->v[x->l+x->sz-1]),x->delr();}T& get(C unsigned p){unsigned i=0;for(X *x=B;x != E;i+=x->sz,x=x->nxt)if(i+x->sz > p)R x->v[x->l+p-i];throw index_out_of_bound();}C T& get(C unsigned p)C {unsigned i=0;for(X *x=B;x != E;i+=x->sz,x=x->nxt)if(i+x->sz > p)R x->v[x->l+p-i];throw index_out_of_bound();}public:T & at(C W &p){R get(p);}C T & at(C W &p)C {R get(p);}T & O[](C W &p){R get(p);}C T & O[](C W &p)C {R get(p);}C T & front()C {if(sz==0)throw container_is_empty();R B->v[B->l];}C T & back()C {if(sz==0)throw container_is_empty();R L->v[L->r-1];}I begin()C {R I(V,0,B,0);}_ cbegin()C {R _(begin());}I end()C {R I(V,sz,E,0);}_ cend()C {R _(end());}I last()C {R I(V,sz-1,L,L->sz-1);}bool empty()C {R sz==0;}W size()C {R sz;}I insert(I p,C T &value){if(V != p.id)throw invalid_iterator();if(p.rk==0)R push_front(value),begin();else if(p.rk < 0 || p.rk > sz)throw index_out_of_bound();else if(p.rk==sz)R push_back(value),last();if(p.b->sz < bSiz)R sz++,p.b->insert(p.p,value),p;R H(p.b),insert(I(p.id,p.rk),value);}I erase(I p){if(V != p.id)throw invalid_iterator();if(p.rk < 0 || p.rk >= sz)throw index_out_of_bound();else if(p.rk==0)R pop_front(),begin();else if(p.rk==sz-1)R pop_back(),end();sz--,p.b->erase(p.p);if(p.b->sz==0)M.Del(p.b);else if(p.b->sz+p.b->nxt->sz <= bSiz * (wRat-1)/ wRat)S(p.b);R I(p.id,p.rk);}void push_back(C T &value){if(L->rsiz()==0 && L->lsiz()< maxW)M.New(L,E);sz++,L->addr(value);}void push_front(C T &value){if(B->lsiz()==0 && B->rsiz()< maxW)M.New(E,B);sz++,B->addl(value);}void pop_back(){if(sz==0)throw container_is_empty();sz--,L->delr();if(L->sz==0)M.Del(L);}void pop_front(){if(sz==0)throw container_is_empty();sz--,B->dell();if(B->sz==0)M.Del(B);}};}
